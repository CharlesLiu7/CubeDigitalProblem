# Cube Digit Problem
## open and close
主要对A*算法添加了一个open和close集来查重。
1. 当节点从优先队列中pop出来时，把该节点从开启列表中删除，然后添加到关闭列表中。
2. 拓展节点时检查所有相邻格子。跳过那些已经在关闭列表中（查重），然后把他们添加进开启列表。 如果某个相邻格已经在开启列表里了，检查现在的这条路径是否更好，换句话说，检查如果我们用新的节点的话，f值是否会更低一些，如果不是，那就什么都不做，更新节点信息。

## optimize 优化

1.	本实验采取使用C++的priority_queue<>，这个模板类使用堆实现优先队列，相对而言是O(lgn)时间复杂度的。事实上可以采取时间复杂度为O(1)的计数排序来加速。
2.	本实验采取C++的unordered_set<>来实现查重，时间复杂度为O(1)。
3.	Unordered_set的哈希函数 bkdr 字符串哈希算法，碰撞较少。事实上可以采取康托展开的哈希算法，但是对于27！量级的本实验而言有些杀鸡用牛刀的效果。
4.	在一开始创建全局变量unordered_set时，初始化表长（根据80steps的测量到的空间大小），在Visual Studio的采样性能分析中可以看到malloc的耗时会明显减少。
5.	Priority_queue和unordered_set中都存储指针，节省空间。
6.	在计算H2的启发函数时，将重复的工作提出来，放在初始化和准备阶段计算，这样只计算一遍，会明显加快速度。
7.	优先队列中priority_queue的比较函数，在f=g+h值一样的情况下，h函数较小的排在前面，这样拓展节点时会尽快拓展到目标节点。
8.	使用open和close集来查重。
9.	还可以做的优化：可以采用Pool来减少一遍又一遍的malloc，但经实测发现减少的时间复杂度是毫秒级的，就没采用这个优化。
10.	还可以做的优化：采样显示计算h函数占了27%左右的时间，所以可以采用相对计算的方法得到h函数，而不是每次重新计算一下。
11.	总的来说空间复杂度是指数级的。

## 测时
系统： windows 10

IDE： Visual Studio 2015

编译结果： Release x86

内存： 4GB

主频： 1.7-3.2GHz

时间测量结果： 时间/秒 F表示因为内存使用超过2G导致非法访存或者耗时未得到结果

| source| Steps	| A* h1	| A* h2|	
| ---	
| 5	| 5	| 0	| 0|	
| 10	| 10	| 0 	| 0.001|	
| 15	| 15	| 0.001	| 0|	
| 20	| 16	| 0 	| 0.001|	
| 25	| 25	| 0.626	| 0.007|	
| 30	| 30	| 2.668	| 0.004|	
| 35	| 35	| F	| 0.049|	
| 40	| 32	| 14.381	| 0.066|	
| 45	| 41	| F	| 0.094|	
| 50	| 28	| 0.428	| 0.005|	
| 55	| 47	| F	| 7.229|	
| 60	| 50	| F	| 1.998|	
| 65	| 49	| F	| 9.777|	
| 70	| 52	| F	| 12.466|	
| 75	| 61	| F	| 15.352|	
| 80	| 56	| F	| F|	
| 85	| 47	| F	| F|	
| 90	| 52	| F	| 0.112|	
| 95	| 61	| F	| F|	
| 100	| 64	| F	| F|	
## source

steps = 5	
1	2	3	
4	5	0	
7	9	6	

10	11	12	
-1	13	-1	
14	8	15	

17	18	19	
20	21	22	
23	24	16	


steps = 10	
1	11	2	
4	5	3	
7	8	6	

17	0	12	
-1	13	-1	
14	15	9	

18	10	19	
20	21	22	
23	24	16	



steps = 15	
4	2	3	
7	6	0	
8	5	9	

1	10	11	
-1	21	-1	
14	13	15	

17	18	12	
20	22	19	
23	24	16	


steps = 20	
1	3	12	
4	5	6	
14	7	9	

10	0	2	
-1	11	-1	
23	13	8	

17	18	19	
20	21	22	
24	16	15	



steps = 25	
1	2	3	
4	7	6	
14	5	9	

10	11	12	
-1	0	-1	
13	15	8	

20	17	19	
18	21	24	
23	22	16	



steps = 30	
6	1	2	
4	7	9	
8	5	24	

10	11	3	
-1	13	-1	
15	0	22	

17	18	12	
20	21	19	
14	16	23	

steps = 35	
4	2	3	
0	12	6	
8	24	9	

5	1	19	
-1	11	-1	
7	13	15	

10	18	22	
17	20	16	
23	14	21	



steps = 40	
4	1	6	
7	5	9	
20	14	8	

10	11	2	
-1	13	-1	
3	0	16	

17	18	12	
21	22	19	
23	15	24	



steps = 45	
3	10	11	
4	23	6	
5	8	9	

1	17	2	
-1	24	-1	
7	16	22	

20	18	12	
14	21	0	
15	13	19	



steps = 50	
11	1	3	
10	2	6	
4	9	15	

20	0	12	
-1	5	-1	
7	13	8	

17	18	19	
21	22	16	
14	23	24	


steps = 55	
1	0	3	
4	7	8	
23	14	6	

10	5	19	
-1	11	-1	
2	16	12	

21	17	22	
24	18	15	
20	13	9	


steps = 60	
10	7	3	
4	20	5	
14	13	0	

17	18	11	
-1	2	-1	
21	1	6	

24	12	19	
8	23	22	
15	16	9	



steps = 65	
11	8	3	
7	9	4	
23	0	6	

17	2	12	
-1	13	-1	
20	15	16	

1	10	5	
21	24	19	
22	14	18	



steps = 70	
4	12	1	
5	2	3	
0	8	6	

11	19	22	
-1	9	-1	
16	10	14	

23	17	18	
21	20	24	
7	13	15	



steps = 75	
24	10	12	
17	13	3	
22	6	9	

0	2	11	
-1	20	-1	
1	16	15	

18	23	19	
5	7	21	
8	4	14	



steps = 80	
4	12	5	
11	8	2	
1	6	14	

17	3	24	
-1	19	-1	
7	13	9	

0	22	18	
10	23	16	
20	21	15	



steps = 85	
10	2	1	
4	13	3	
7	8	9	

0	5	11	
-1	15	-1	
14	16	12	

17	6	21	
20	19	22	
18	23	24	



steps = 90	
0	3	10	
13	1	5	
4	15	9	

12	6	2	
-1	23	-1	
8	22	16	

21	7	18	
11	17	24	
14	20	19	



steps = 95	
4	11	19	
14	7	1	
6	15	12	

10	5	13	
-1	21	-1	
24	8	16	

18	0	22	
23	20	17	
2	3	9	



steps = 100	
20	6	2	
7	5	11	
0	13	14	

10	15	18	
-1	1	-1	
12	9	4	

3	22	19	
17	23	24	
8	21	16	

